## 快速乘、快速模乘
### 问题描述
我们需要解决的问题就是计算出a * b mod p   
按照普通的算法，只需要一行即可。但有的时候a与b的规模相当大，达到10^18，相乘就会溢出。   
参考快速幂的想法，我们同样可以把b拆为一个二进制数。

例如  b=9，对应的二进制数为1001，那么
> 9 = 1 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0

可以得到性质1：
> a * 9 = a * (2^3 + 2^0)

根据这个性质我们就可以做快速乘和快速模乘了。

### 快速乘
我们用ans来记录当前的答案，用`b & 0x01`判断当前位是1，还是0。  
根据性质1我们可以知道，如果我们判断到当前二进制数的位数上是1（例如9的第0位和第3位），那么`ans = ans + a * 2`，否则`ans`不用更新。   
而无论`ans`是否更新，a和b都要更新。   
b需要判断高一位是否为1（即右移一位），a需要往前进一位（即左移一位）。
```c++
//快速乘法：计算a*b
public static int qmul_num(int a, int b) {
    int ans = 0;
    while (b != 0) {
        if ((b & 1) != 0) {
            ans += a;
        }
        b >>= 1;
        a <<= 1;
    }
    return ans;
}
```
快速模乘就是比快速乘多了取模这一步。
```c++
//快速乘法 + 取模 
public static int qmul_mod(int a, int b, int mod) {
    int ans = 0;
    while (b != 0) {
        if (((b %= mod) & 1) != 0) {
            ans += a %= mod;
        }
        b >>= 1;
        a <<= 1;
    }
    return ans % mod;
}
```