# 浅谈数位DP
## 问题引入
在了解数位dp之前，先来看一个问题：   
>例1.求a~b中不包含62的数的个数. 0 < a, b < 2 * 10^9.

注意到n的数据范围非常大，暴力求解是不可能的，考虑动态规划。但如果直接记录下数字，数组会开不起，该怎么办呢？这时要用到数位dp。

数位dp一般应用于：   
- 求出在给定区间[a, b]内，符号条件P(i)的数i的个数。  
- 条件P(i)一般与数的大小无关，而与**数的组成**有关。

## 设计搜索
这里我们使用记忆化搜索来实现数位dp。本质上记搜就是dp。
### 一、搜索过程
从起点向下搜索，到最底层得到方案数，一层一层向上返回答案并累加，最后从搜索起点得到最终答案。   
对于[a, b]区间问题，我们一般把他转化为两次数位dp，即找[0, a - 1]和[0, b]两段，再将结果相减就得到了需要的[a, b]。

### 二、状态设计
如果理解了上述过程，我们需要考虑的就是怎样判断现在在哪一层，怎样判断当前的状态——这就需要我们传进一些参量。   
- dfs函数需要哪些参量？
    1. 首先是数位dp基本的量数字位数 pos，记录答案的 st，最高位限制 limit（这个后面会讲）
    2. 我们还需要一个判断判断前导0的标记 lead（这个后面也会讲）
    3. 由于数位dp解决的大多是数字组成问题，所以经常要比较当前位和前一位或前几位的关系（根据题意而定），
       所以一般在dfs()中也要记录前一位或前几位数 pre方便比较
    4. 除此之外还可以传进更多参量以区分状态，视题意而定

**Note:**
1. 前导标记lead
    由于我们要搜的数可能很长，所以我们的直接最高位搜起。   
    举个例子：假如我们要从[0,1000]找任意相邻两数相等的数，显然111,222,888等等是符合题意的数，   
    但是我们发现右端点1000是四位数，因此我们搜索 的起点是0000，而三位数的记录都是0111,0222,0888等等。   
    而这种情况下如果我们直接找相邻位相等则0000符合题意而0111,0222,0888都不符合题意了，所以我们要加一个前导0标记。
    1. 如果当前位lead=1而且当前位也是0，那么当前位也是前导0，pos+1继续搜；
    2. 如果当前位lead=1但当前位不是0，则本位作为当前数的最高位，pos+1继续搜；（注意这次根据题意st或其他参数可能发生变化）
    
    当然前导0有时候是不需要判断的，上述的例子是一个有关数字结构上的性质，0会影响数字的结构，所以必须判断前导0；  
    而如果我们研究的是数字的组成（例如这个数字有多少个 11之类的问题），0并不影响我们的判断，这样就不需要前导0标记了。   
  
 
2. 最高位标记limit   
   我们知道在搜索的数位搜索范围可能发生变化；   
   举个例子：我们在搜索[0,555]的数时，显然最高位搜索范围是0~ 5，而后面的位数的取值范围会根据上一位发生变化：
    1. 当最高位是1~ 4时，第二位取值为[0,9];
    2. 当最高位是5时，第二位取值为[0,5].

   为了分清这两种情况，我们引入了limit标记：
    1. 若当前位limit=1而且已经取到了能取到的最高位时，下一位limit=1；
    2. 若当前位limit=1但是没有取到能取到的最高位时，下一位limit=0；
    3. 若当前位limit=0时，下一位limit=0.

   我们设这一位的标记为limit，这一位能取到的最大值为res，则下一位的标记就是i==res&&limit（ i枚举这一位填的数）

### 三、dp值的记录和使用
最后我们考虑dp数组下标记录的值。   
本文介绍数位dp是在记忆化搜索的框架下进行的，每当找到一种情况我们就可以这种情况记录下来，等到搜到后面遇到相同的情况时直接使用当前记录的值。   
dp数组的下标表示的是一种状态，只要当前的状态和之前搜过的某个状态完全一样，我们就可以直接返回原来已经记录下来的dp值。   
注意，我们返回的dp值必须和当前处于完全一样的状态，这就是为什么dp数组下标要记录pos,pre等参量了。
---
接着上面的例子，范围[0,123456]   
如果我们搜到了1234?，我们能不能直接返回之前记录的：当前第5位，前一位是4时的dp值？  
答案是否定的   
我们发现，这个状态的dp值被记录时，当前位也就是第5位的取值是[0,9]，而这次当前位的取值是[0,5]，方案数一定比之前记录的dp值要小。   
当前位的取值范围为什么会和原来不一样呢？  
如果你联想到了之前所讲的知识，你会发现：现在的limit=1，最高位有取值的限制。   
因此我们可以得到一个结论：当limit=1时，不能记录和取用dp值！   
类似上述的分析过程，我们也可以得出：当lead=1时，也不能记录和取用dp值！

## 代码模板
```c++
/**
 * @pos      : 当前搜到的位数
 * @limit    : 记录当前所选的数范围是否收到限制
 * @state,...: 按需记录填过数的状态(可选，如前一位数、数位和、返回值等)
 * @lead     : 记录当前位是否位前导0(可选)
 */
ll dfs(int pos,int pre,int st,...,int lead,int limit) {
    if(pos==-1) return ...; //返回填完的数是否满足条件
    //当前状态已经搜索过，直接使用dp值
    if(dp[pos][state]...!=-1&&!limit&&!lead) return dp[pos][state]...;
    ll ret=0; //暂时记录当前方案数
    int up=limit?a[pos]:9; //当前位能取到的最大值
    
    for(int i=0;i<=up;i++){
    //有前导0并且当前位也是前导0
    if(!i&&lead) ret+=dfs(pos-1,...,1,limit&&i==up);
    //有前导0但当前位不是前导0，当前位就是最高位
    else if(i&&lead) ret+=dfs(pos-1,...,0,limit&&i==up);
    else if(...) ...;
    }
    
    if(!limit&&!lead) dp[pos][state]...=ret; //当前状态方案数记录
    return ret;
}

ll solve(ll x) {
    pos=0; //数位长度
    while(x) a[pos++]=x%10,x/=10;
    memset(dp,-1,sizeof(dp)); //初始化-1（因为方案数可能为0）
    return dfs(pos-1,...,1,1);
}

int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%lld%lld",&l,&r);
        if(l) printf("%lld",part(r)-part(l-1));//[l,r](l!=0)
        else printf("%lld",part(r)-part(l));//从0开始要特判
    }
    return 0;
}
```
    
